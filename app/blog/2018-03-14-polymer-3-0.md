---
title:  "Hands-on with the latest Polymer 3.0 preview"
---

In a previous [blog post on paths and names](2018-02-26-3.0-preview-paths-and-names), we announced some changes to the way we handle module imports in Polymer 3.0, and described why we made those changes. We're happy to announce that you can try out the new import syntax in the latest Polymer 3.0 preview!

* [Simpler module imports](#packagenames)
* [Renamed base element export in polymer-element.js](#renamed)
* [Dynamic imports](#dynamicimports)
* [Tools](#tools)
* [What next?](#whatnext)
* [Sample app and element with the new preview](#samples)

## Simpler module imports {#packagenames}

In this release, we add support for importing npm modules using their package names. From now on, we recommend using package names instead of paths to import npm modules in your Polymer apps and elements.

For example, instead of referring to the Polymer library by its path, as we did in previous Polymer 3.0 releases:

Old import syntax { .caption }

```js
import { Element as PolymerElement } from './node_modules/@polymer/polymer/polymer-element.js';
```

From this release onwards, you can refer to the Polymer library and components-and other npm modules-using package names:

New import syntax { .caption }

```js
import { PolymerElement } from '@polymer/polymer/polymer-element.js';
```

At present, web browsers need the full path to an import to process it. A discussion on supporting imports by package name in browsers is ongoing-for example, see this [proposal for pacakge name maps](https://github.com/domenic/package-name-maps). 

For now, the Polymer CLI tools automatically resolve and rewrite imports that use package names to imports that use paths, producing web-compatible code for the browser.

### What you need to do

**If you're converting a Polymer 2.x project to Polymer 3.0:**

You don't need to change your code-the [Polymer Modulizer](https://github.com/Polymer/polymer-modulizer) will handle that. We recommend you run the modulizer with the `--import-style=name` option to generate Polymer 3.0 code that uses package names to import modules. 

**If you're updating earlier Polymer 3.0 code to use the new preview:**

We recommend you change any imports of npm packages to use package names, like in [the examples below](#examples).

**If you're writing Polymer 3.0 code with the new preview:**

* We recommend you import npm packages using their package names, like in [the examples below](#examples). 

**Everyone:**

* Continue to use paths to import modules that are parts of your app. For example:
  
  ```js
  // this syntax won't change
  import './my-view.js'
  ```

  Valid import paths that start with `/`, `./`, or `../` won't be transformed by the Polymer CLI tools.

* When using the Polymer CLI tools to work with code that uses the new 
  Polymer 3.0 preview, set the `--npm` and `--module-resolution=node` options. 
  You can set these options from command line flags, or from `polymer.json`. See
  the section of this post on [Tools](#tools) for detailed instructions. 

### Potential questions and answers

**Can I still use paths to import my dependencies?**

Yes. Valid import paths that start with `/`, `./`, or `../` won't be transformed by the Polymer CLI tools.

**What happens if I mix paths and package names?**

Your code will work as normal. Valid import paths that start with `/`, `./`, or `../` won't be transformed by the Polymer CLI tools.

**Which tools have been updated to handle imports that use package names?**

All of the Polymer CLI tools have been updated with this functionality. Set the `--module-resolution=node` and `--npm` options to enable it. 

See the [Tools](#tools) section of this post for more detail.

### Use the new import syntax {#examples}

To import the Polymer library:
```js
import { PolymerElement } from '@polymer/polymer/polymer-element.js';
```

To import a helper element from the Polymer library:
```js
import '@polymer/polymer/lib/elements/dom-if.js';
```

To import a Polymer Element:
```js
import '@polymer/paper-checkbox/paper-checkbox.js';
```

To import a behavior:
```js
import {IronResizableBehavior}
    from '@polymer/iron-resizable-behavior/iron-resizable-behavior.js';
```

To import utility modules like `async` that export several members, you can import individual members, or import the entire module:

```js
import * as async from '@polymer/polymer/lib/utils/async.js'
async.microTask.run(callback);
```

The Polymer 3.0 API docs are still in progress-so for the moment, refer to the [Polymer 3.0 preview source code](https://github.com/Polymer/polymer/tree/__auto_generated_3.0_preview) to determine what a module exports.

#### Old Polymer 3.0 preview syntax

```js
/* my-app.js
 * 
 * Old syntax used path names.
 * Also, the main export of polymer-element.js
 * was called Element and had to be renamed on import. 
 */
import { Element as PolymerElement } from './node_modules/@polymer/polymer/polymer-element.js';
import './node_modules/@polymer/polymer/lib/elements/dom-if.js';
import './node_modules/@polymer/paper-checkbox/paper-checkbox.js';
import './my-view.js';

class MyApp extends PolymerElement {
  static get template () {
    // Old syntax let you return a string literal.
    return `
      <h1>Hello World</h1>
      <template is="dom-if" if="true">
        <paper-checkbox>I like pie</paper-checkbox>
      </template>
      <my-view></my-view>
    `;
  }
}
customElements.define('my-app', MyApp);
```

```html
<!-- index.html -->
<!-- this doesn't change -->
<!-- polyfills, metadata, etc -->
<script type="module" src="./my-app.js">
<my-app></my-app>
```

#### Current Polymer 3.0 preview syntax

```js
/* 
 * my-app.js
 * 3 changes:
 * - Import statements now use package names instead of paths
 * - polymer-element.js exports PolymerElement instead of Element, no 
 *   need to rename it
 * - Import the html helper function from polymer-element.js for templates
*/
import { PolymerElement, html } from '@polymer/polymer/polymer-element';
import '@polymer/polymer/lib/elements/dom-if';
import '@polymer/paper-checkbox/paper-checkbox';
// Continue to use paths for importing other modules that are part of your app
import './my-view.js';

class MyApp extends PolymerElement {
  static get template () {
    // Always return an HTMLTemplateElement, not a string literal
    return html`
      <h1>Hello World</h1>
      <template is="dom-if" if="true">
        <paper-checkbox>I like pie</paper-checkbox>
      </template>
      <my-view></my-view>
    `;
  }
} 
customElements.define('my-app', MyApp);
```

```html
<!-- index.html -->
<!-- this doesn't change -->
<!-- polyfills, metadata, etc -->
<script type="module" src="./my-app.js">
<my-app></my-app>
```

## Renamed base element export in polymer-element.js {#renamed}
Previously, it was necessary to change the symbol for the main export of `@polymer/polymer/polymer-element.js` from `Element` to some other symbol on import. This export has been renamed to `PolymerElement`. You can now use this symbol without changing it: 

```js
import { PolymerElement, html } from '@polymer/polymer/polymer-element.js';

class MyApp extends PolymerElement {
  //...
}
customElements.define('my-app', MyApp);
```

## Dynamic imports {#dynamicimports}
The latest versions of Chrome and Safari support dynamic imports using the `import()` operator (a polyfill is still to come).

The import operator acts like a function, and returns a `Promise`:

```js
import('my-view1.js').then((MyView1) => {
  console.log("MyView1 loaded");
}).catch((reason) => {
  console.log("MyView1 failed to load", reason);
});
```

Dynamic imports enable lazy-loading of resources, replacing the functionality that we previously used for this in Polymer 2.0 (`Polymer.importHref()`). 

## Tools {#tools}

We have made changes to the Polymer CLI tools to support imports using package names. 

You can look at the [Polymer CLI changelog](https://github.com/Polymer/polymer-cli/blob/master/CHANGELOG.md) for full details of the changes, but here's a summary:

All of the Polymer CLI tools now handle package name imports. You need to set the `--module-resolution=node` and `--npm` options to enable it. 

* The Polymer CLI development server (`polymer serve`) resolves package names to paths, and rewrites them on-the-fly. 

* The Polymer CLI build tools (`polymer build`, `polymer-analyzer`, `polymer-bundler`,
  etc) handle these transformations as well. `polymer build` outputs web-compatible
  code.

When using the Polymer CLI tools to work with the new Polymer 3.0 preview, set the `--npm` and `--module-resolution=node` options. You can set these options from command line flags, or from `polymer.json`.

To set the options from command line flags, for example: 

```bash
polymer serve --npm --module-resolution=node
```

```bash
polymer build --npm --module-resolution=node
```

To set the options from your `polymer.json` file, add them as top-level properties. For example:

```json
{ 
  //...
  "npm": true,
  "moduleResolution": "node",
  //...
  "builds": [{
    //...
  }]
}
```

The Polymer CLI tools will use the options you define in `polymer.json`.

### New polymer.json properties

To support new functionality, we made a few new `polymer.json` options you should know about. These options are all top-level properties. 

* `root`: Optional string. Defaults to the current working folder.
  
  The path to the root project folder. This can be an absolute path, or a path relative to the current working folder. 

  ```json
  "root": "/full/path/to/myfolder"
  ```
  
  ```json
  "root": "a/relative/path"
  ```

* `moduleResolution`: Optional string. Defaults to `"none"`.

  Specifies how the Polymer CLI tools will resolve package names.

  To disable module specifier rewriting: 

  ```json
  "moduleResolution": "none"
  ```
  
  To use Node.js resolution to find modules: 

  ```json
  "moduleResolution": "node"
  ```
  
* `componentDir`: Optional string. If `npm` is `true`, defaults to `"node_modules"`. 
  
  Specifies the folder containing this project's components. 

  ```json
  "componentDir": "path/to/components"
  ```

* `npm`: Optional boolean. 

  Sets `componentDir` to `"node_modules"`.

  ```json
  "npm": true
  ```

## What next? {#whatnext}

With this preview, the core library is feature complete, marking another step on the road to a stable Polymer 3.0 release.

Here's what's still in progress:

* Lots of testing.
* A complete set of developer and API docs for Polymer 3.0.
* The finishing touches (and lots more testing) for the Polymer 3.0 elements. See the [elements status page](https://github.com/Polymer/polymer-modulizer/blob/master/docs/polymer-3-element-status.md) for more info.
* JavaScript bundling. Our implementation is based on [Rollup](https://github.com/rollup/rollup).
* Lots more testing of the Polymer CLI tools.
* Template Polymer 3.0 apps and elements for `polymer init`.
* Did we mention testing?

[See the Polymer 3.0 Roadmap for more info](https://github.com/Polymer/project/blob/master/Roadmap.md).

## Sample app and element with the new preview {#samples}

We are working on Polymer 3.0 app and element templates that youâ€™ll be able to generate from the Polymer CLI with the polymer init command. In the mean time, take a look at this [sample Polymer 3.0 app built with the new preview](https://github.com/katejeffreys/start-polymer3). A [hosted demo is also available](https://start-polymer3.firebaseapp.com/).

**The sample app uses dynamic imports.** The sample app shows an example of a dynamic `import` statement. For this reason, it only works in the latest versions of Chrome and Safari. { .alert .alert-warning }
